### Utility functions for mortality-unemployment paper
### Insang Song
### 11/14/2021

### Fitting INLA model ####
# form: formula
# data: main dataset object. data.frame
# dis: cause of death grouped by the IHME
# family: likelihood distribution assumption
# graph: binary spatial contiguity matrix. generated by spdep::nb2mat
# baseyear: set as 2000 in this study. the standard year.
# standardize: standardize the covariates?
# logarithm: log-transform the outcome?
# logarithm_all: log-transform all the variables?
# lincomb: linear combination term generated by INLA::inla.make.lincombs
# cores: the number of threads will be used for stages 1 and 2. should follow "x:y" format
# verbose: show all the internal messages while fitting models
# theta: initial values of thetas
# openmp.strategy: see ?INLA::control.compute; as of March 2022, the PARDISO solver option is not available.
fit_inla_spt <- function(form = form.bp, data, dis = 'Allcauses', 
                         family = 'gaussian',
                         graph, baseyear = 2000, standardize = FALSE, 
                         logarithm = FALSE, logarithm_all = FALSE,
                         lincomb = NULL, cores = "6:1", verbose = TRUE,
                         theta = NULL, openmp.strategy = 'pardiso'){
  inla.setOption(mkl=FALSE)
  data.p <- data %>% filter(disease == dis & year > baseyear) %>% 
    mutate(GEOID = as.integer(factor(GEOID)),
           year = year - baseyear) %>% 
    mutate(GEOID1 = GEOID, GEOID2 = GEOID,
           GEOID3 = GEOID, GEOID4 = GEOID,
           GEOID_year = str_c(GEOID, '_', year),
           GEOID_year_int = 1:nrow(.),
           year1 = year, year2 = year, year3 = year) %>%
    mutate_all(.funs = list(~ifelse(is.na(.), median(., na.rm = TRUE), .)))
  data.pu <- data.p

  if (logarithm){
    data.pu <- data.pu %>% mutate(Mortrate = log(Mortrate))
    if (logarithm_all) {
      data.pu <- data.pu %>% 
        mutate_at(.vars = vars(PELDER, PNONWHITE, MEDINCOME, PUNIVABOVE, PPOVTBELOW, PRURAL, PRENTER, PHSINGLE, UELAG1, UELAG2), 
                  .funs = list(~ifelse(min(.)==0, log(.+1), log(.)))) %>%
        arrange(year, GEOID) # 102220
    }
  }
  if (standardize == TRUE){
    data.pu <- data.pu %>% 
      mutate_at(.vars = vars(PELDER, PNONWHITE, MEDINCOME, PUNIVABOVE, PPOVTBELOW, PRURAL, PRENTER, PHSINGLE, UELAG1, UELAG2), .funs = list(~scale(.))) %>%
      arrange(year, GEOID) # 102220
      if (!logarithm) {
        data.pu = data.pu %>% mutate(Mortrate = as.vector(scale(Mortrate)))
      }
  } else {
    data.pu <- data.pu %>% arrange(year, GEOID) # 102220
  }
  # added hyperparameter priors
  # ntheta: BYM case (*2) change otherwise
  ntheta <- as.character(form)[3] %>% strsplit(., split = ' + ', fixed = T) %>% .[[1]] %>% 
    grepl('^f.*', .) %>% sum
  ntheta <- ntheta * 2 + 1
  thetas <- 
    rep(0, ntheta)
  if (is.null(lincomb)){
    finla <- inla(formula = form, data = data.pu, 
                  family = family,
                  control.compute = list(waic = TRUE, dic = TRUE, cpo = TRUE,
                                        openmp.strategy = openmp.strategy), 
                  verbose = verbose,
                  num.threads = cores,
                  blas.num.threads = cores,
                  control.inla = control.inla(#cmin = -0.0, 
                                              h=1e-4, b.strategy = 'keep', strategy = "adaptive", 
                                              int.strategy = "eb", restart = 3, #optimiser = 'gsl',
                                              stupid.search.factor = 2,
                                              tolerance = 1e-3, npoints = 9), #diagonal = 1e4
                  control.lincomb = control.lincomb(verbose = FALSE),
                  control.predictor = list(compute = TRUE),
                  control.mode = list(restart = TRUE, fixed = FALSE,
                                      theta = theta)) # the length of theta should be changed accordingly
  }
  else if (!is.null(lincomb)){
    finla <- inla(formula = form, data = data.pu, 
                  family = family,
                  control.compute = list(waic = TRUE, dic = TRUE, cpo = TRUE,
                                        openmp.strategy = openmp.strategy), 
                  verbose = verbose,
                  num.threads = cores,
                  blas.num.threads = cores,
                  control.inla = control.inla(#cmin = -0.0, 
                                              h=1e-4, b.strategy = 'keep', strategy = "adaptive", 
                                              int.strategy = "eb", restart = 3, #optimiser = 'gsl',
                                              stupid.search.factor = 2,
                                              tolerance = 1e-3, npoints = 9), #diagonal = 1e4
                  control.lincomb = control.lincomb(verbose = FALSE),
                  lincomb = lincomb,
                  #control.fixed = list(prec.intercept = 0.0001),
                  control.predictor = list(compute = TRUE),
                  control.mode = list(restart = TRUE, fixed = FALSE,
                                      theta = theta)) # the length of theta should be changed accordingly
  }

  return(finla)
}


# inla_res: inla model fit results
# mapo: original map you want to use for mapping. Should be intact with unique county IDs names "GEOID"
# year_select: which year you want to choose to visualize
# style_cl: see style argument description in ?tmap::tm_fill
# mapping: print map while returning a cleaned data.frame object
# rand.d: the random effect included in the inla object. depending on the model specification (i.e., formula)
map_inla_rs <- function(inla_res, mapo, year_select = 2009, style_cl = 'cont', mapping = FALSE, rand.d = 1){
  mapo.base <- mapo %>% 
    dplyr::select(GEOID) %>% 
    arrange(GEOID)

  if (is.null(rand.d)){
      ind <- dim(inla_res$summary.lincomb.derived)[1]
  } else {
      ind <- dim(inla_res$summary.random[[rand.d]])[1]
        if (rand.d %in% c(1, 3, 5)){
        ind <- ind / 2
        }
  }

  # fix: 20191228, 1r 1s 2r 2s 3r 3s...
  if (!is.null(rand.d)){
    inla_res.mean <- inla_res$summary.random[[rand.d]]
    if (ind > nrow(mapo)){
      inla_res.mean1 <- inla_res.mean %>% 
        filter(ID %in% 1:3108) %>% 
        data.frame %>% 
        mutate(year = rep(2001:2014, each=3108)) %>% 
        mutate(GEOID = rep(mapo.base$GEOID,  14)) 
        if (!is.null(mode)){
            inla_res.mean2 <-  inla_res.mean %>% 
                filter(ID %in% 3109:6216) %>% 
                data.frame %>% 
                mutate(year = rep(2001:2014, each=3108)) %>% 
                mutate(GEOID = rep(mapo.base$GEOID,  14)) 
            inla_res.mean1 <- inla_res.mean1 %>%
                mutate(mean = mean + inla_res.mean2$mean)                
        }
    } else {
      inla_res.mean1 <- inla_res.mean %>% 
        mutate(year = year_select) %>% 
        filter(ID %in% 1:3108) %>%
        mutate(GEOID = mapo.base$GEOID)
    }
    
  } else {
    inla_res.mean1 <- inla_res$summary.lincomb.derived %>%
      mutate(year = rep(2001:2014,  each = 3108)) %>% 
      mutate(GEOID = rep(mapo.base$GEOID, 14)) 
      if (additional) {
        inla_res.mean1 = inla_res.mean1 %>%
          mutate(mean = mean + inla_res$summary.fixed$mean[2])
      }

  }
  mapo.base.yr <- mapo.base %>% 
    left_join(inla_res.mean1 %>% filter(year == year_select)) 
  
  if (mapping){
    (tm_shape(mapo.base.yr) +
      tm_fill('mean', palette = '-RdBu', style = style_cl) +
      tm_borders(col = 'light grey', lwd = 0.075)) -> mapo_tm
    print(mapo_tm)
    
  }
  return(mapo.base.yr)
}



# idata: inla object
# map: sf object for mapping. county boundaries in this context
# rand.d: the results of random effects. depending on the model specification
# file.export: export the map to an image?
# map_state: state boundary
# title: map title added above the legend
# wd: width
# hg: height
# filename: file name
# return_map: want to have a tmap object?
# animation: animation with a fixed map frame instead of faceted maps by year?
map_dexport <- function(idata, map = mort.simp, rand.d = 5, file.export = FALSE,
                        map_state = NULL,
                        brks = NULL,
                        pdir = './output/', 
                        title = 'Posterior mean', wd = 50, hg = 50,
                        filename,
                        return_map = FALSE,
                        animation = FALSE){
  
  if (is.null(rand.d)){
      ind <- dim(idata$summary.lincomb.derived)[1]
  } else {
      ind <- dim(idata$summary.random[[rand.d]])[1]
        if (rand.d %in% c(1, 3, 5)){
        ind <- ind / 2
        }
  }

  if (ind > nrow(map)){
    2001:2014 %>% 
      split(.,.) %>% 
      lapply(function(x) map_inla_rs(idata, map, year_select = x, rand.d = rand.d)) -> map_rs_alll
    map_rs_all <- do.call(rbind, map_rs_alll) %>% 
      dplyr::select(GEOID, year, mean)
    
    tms <- tm_shape(map_rs_all) +
      tm_facets(by = 'year') +
      tm_borders(col = 'light grey', lwd = 0.08) +
      tm_fill('mean', palette = '-RdBu', midpoint = 0, 
              n = ifelse(!is.null(brks), length(brks), 6), 
              style = ifelse(!is.null(brks), 'fixed', 'fisher'),
              breaks = brks,
              title = title) +
      tm_layout(frame = FALSE, frame.lwd = NA, panel.label.bg.color = NA, 
                panel.label.size = 1.5,
                legend.outside = TRUE, legend.outside.position = 'right',
                outer.margins = c(0.01,0.01,0.01,-0.08))
    if (!is.null(map_state)) {
        tms <- tms + 
            tm_shape(map_state) +
            tm_borders(col = 'black', lwd = 0.88)
    }
  } else {
    map_inla_rs(idata, map, year_select = 2014, rand.d = rand.d) -> map_rs_all
    tms <- tm_shape(map_rs_all) +
      tm_borders(col = 'light grey', lwd = 0.08) +
      tm_fill('mean', palette = '-RdBu', midpoint = 0, n = 6, style = 'fisher',
              title = title) +
      tm_layout(frame = FALSE, frame.lwd = NA, panel.label.bg.color = NA, 
                panel.label.size = 1.5,
                legend.outside = TRUE, legend.outside.position = 'right',
                outer.margins = c(0.01,0.01,0.01,-0.08))
    if (!is.null(map_state)) {
        tms <- tms + 
            tm_shape(map_state) +
            tm_borders(col = 'black', lwd = 0.88)
    }

  }
  if (return_map){
    return(map_rs_all)
  }


  if (file.export){
    target_file <- str_c(pdir, filename)
    if (animation){
      tms = tms +
        tm_facets('year', free.coords = F, nrow = 1, ncol = 1)
      tmap_animation(tms, filename = target_file, width = wd, height = hg, units = 'px', fps = 2
                    )
    } else {
    tmap_save(tms, filename = target_file, width = wd, height = hg,
              units = 'cm', dpi = 300, pointsize = 30)
    }

  } else {
      tms
    }
  
}

map_dexport_gg <- function(idata, map = mort.simp, rand.d = 5, file.export = FALSE,
                        pdir = './output/', 
                        filename){
  2001:2014 %>% 
    split(.,.) %>% 
    lapply(function(x) map_inla_rs(idata, map, year_select = x, rand.d = rand.d)) -> map_rs_alll
  map_rs_all <- do.call(rbind, map_rs_alll) %>% 
    dplyr::select(GEOID, year, mean)
  
  tms.gg <- ggplot(data = map_rs_all) +
    facet_wrap(facets = ~year) +
    geom_sf(mapping = aes(fill = mean), col = 'light grey', lwd = 0.08) +
    ggthemes::theme_map() +
    scale_fill_gradient2(
      high = "dark red",
      mid = "beige",
      low = "dark blue",
      midpoint = 0,
      na.value = "grey50"
    )
  
  
  if (file.export){
    target_file <- str_c(pdir, filename)
    
    ggsave(tms.gg, width = 60, height = 40, scale = 0.66, units = 'cm', dpi = 300, 
          path = target_file)
  } else {
    tms.gg
  }
  
}



ts_dexport <- function(idata, rand.d = 4, file.export = FALSE,
                        pdir = './output/', 
                        title = 'Posterior mean', wd = 50, hg = 50,
                        filename,
                        return_gg = FALSE){
  
  gg_ts = idata$summary.random[[rand.d]] %>%
    mutate(Year = 2001:2014) %>%
    ggplot(data = ., 
           mapping = aes(x = Year)) +
        geom_line(mapping = aes(y = mean), lwd = 2, col = 'red') +
        geom_line(mapping = aes(y = `0.025quant`), lwd = 1.5, col = 'dark grey') +
        geom_line(mapping = aes(y = `0.975quant`), lwd = 1.5, col = 'dark grey') +
        theme_bw() +
        theme(axis.text = element_text(size = 16))

  if (file.export){
    target_file <- str_c(pdir, filename)
    ggsave(plot = gg_ts, filename = target_file,
            width = wd, height = hg, units = 'cm', scale = 0.75)
    #dev.off() 
  } else {
      gg_ts
    }
  
}


# Posterior marginals for computing the probability of random effects larger than a specific value
map_emarginal <- function(idata, map = mort.simp, rand.d = 5, 
                        map_state = NULL,
                        file.export = FALSE,
                        pdir = './output/', 
                        title = expression(paste('p(', beta['1it'], '>0)', sep = '')),
                        filename){
  
  if (is.null(rand.d)){
      emarginal <- lapply(idata$marginals.lincomb.derived,
                      function(x) 1- inla.pmarginal(0, x)) 
  } else {
      indx <- rep(1:3108,14) + rep(c(0,2,4,6,8,10,12,14,16,18,20,22,24,26)*3108, each = 3108)
      emarginal <- lapply(idata$marginals.random[[rand.d]][indx],
                      function(x) 1- inla.pmarginal(0, x))
      emarginal <- emarginal
  }
  emarginal <- do.call(c, emarginal)

  2001:2014 %>% 
    split(.,.) %>% 
    lapply(function(x) map %>% mutate(year = x)) -> map_rs_alll
  map_rs_all <- do.call(rbind, map_rs_alll) %>% 
    dplyr::select(year, GEOID) %>% 
    mutate(pmarginal = emarginal)
  

  tms <- tm_shape(map_rs_all) +
    tm_facets(by = 'year') +
    tm_borders(col = 'light grey', lwd = 0.08) +
    tm_fill('pmarginal', palette = 'Blues', breaks=c(0,0.2,0.5,0.8,1),
            title = title) +
    tm_layout(frame = FALSE, frame.lwd = NA, panel.label.bg.color = NA, 
              panel.label.size = 1.5,
              legend.outside = TRUE, legend.outside.position = 'right',
              outer.margins = c(0.01,0.01,0.01,-0.1))
    if (!is.null(map_state)) {
        tms <- tms + 
            tm_shape(map_state) +
            tm_borders(col = 'black', lwd = 0.88)
    }

  if (file.export){
    target_file <- str_c(pdir, filename)
  
    tmap_save(tms, filename = target_file, width = 50, height = 50,
              units = 'cm', dpi = 300, pointsize = 30)

  } else {
      tms
    }
  
}